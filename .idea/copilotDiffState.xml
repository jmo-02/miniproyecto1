<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/miniproyecto1/view/fragment/ItemEditFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/miniproyecto1/view/fragment/ItemEditFragment.kt" />
              <option name="originalContent" value="package com.example.miniproyecto1.view.fragment&#10;&#10;import android.os.Bundle&#10;import android.text.Editable&#10;import android.text.InputFilter&#10;import android.text.TextWatcher&#10;import android.text.method.DigitsKeyListener&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.navigation.fragment.findNavController&#10;import com.example.miniproyecto1.R&#10;import com.example.miniproyecto1.databinding.FragmentItemEditBinding&#10;import com.example.miniproyecto1.model.Inventory&#10;import com.example.miniproyecto1.viewmodel.InventoryViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;&#10;@AndroidEntryPoint&#10;class ItemEditFragment : Fragment() {&#10;&#10;    private lateinit var binding: FragmentItemEditBinding&#10;    private val inventoryViewModel: InventoryViewModel by viewModels()&#10;&#10;    private var productCode: Int = -1&#10;    private var currentInventory: Inventory? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        binding = FragmentItemEditBinding.inflate(inflater, container, false)&#10;        binding.lifecycleOwner = viewLifecycleOwner&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        // Recibir código desde el fragment anterior&#10;        productCode = arguments?.getInt(&quot;code&quot;) ?: -1&#10;&#10;        if (productCode == -1) {&#10;            Toast.makeText(requireContext(), &quot;Error: producto no especificado&quot;, Toast.LENGTH_SHORT).show()&#10;            findNavController().navigateUp()&#10;            return&#10;        }&#10;&#10;        configurarToolbar()&#10;        configurarFiltrosYValidacion()&#10;        observarViewModel()&#10;&#10;        // Cargar datos&#10;        inventoryViewModel.getListInventory()&#10;    }&#10;&#10;    private fun configurarToolbar() {&#10;        binding.topAppBar.setNavigationIcon(R.drawable.ic_arrow_back)&#10;        binding.topAppBar.setNavigationOnClickListener {&#10;            // En lugar de crear una nueva instancia de ItemDetailsFragment, simplemente&#10;            // volvemos al fragmento anterior en la pila para evitar ciclos de navegación.&#10;            findNavController().navigateUp()&#10;        }&#10;    }&#10;&#10;    private fun configurarFiltrosYValidacion() {&#10;        binding.etName.filters = arrayOf(InputFilter.LengthFilter(40))&#10;        binding.etPrice.filters = arrayOf(InputFilter.LengthFilter(20))&#10;        binding.etQuantity.filters = arrayOf(InputFilter.LengthFilter(4))&#10;&#10;        binding.etPrice.keyListener = DigitsKeyListener.getInstance(&quot;0123456789&quot;)&#10;        binding.etQuantity.keyListener = DigitsKeyListener.getInstance(&quot;0123456789&quot;)&#10;&#10;        val watcher = object : TextWatcher {&#10;            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                validarCampos()&#10;            }&#10;            override fun afterTextChanged(s: Editable?) {}&#10;        }&#10;&#10;        binding.etName.addTextChangedListener(watcher)&#10;        binding.etPrice.addTextChangedListener(watcher)&#10;        binding.etQuantity.addTextChangedListener(watcher)&#10;&#10;        binding.btnEdit.setOnClickListener {&#10;            realizarEdicion()&#10;        }&#10;    }&#10;&#10;    private fun validarCampos() {&#10;        val name = binding.etName.text?.toString()?.trim() ?: &quot;&quot;&#10;        val price = binding.etPrice.text?.toString()?.trim() ?: &quot;&quot;&#10;        val quantity = binding.etQuantity.text?.toString()?.trim() ?: &quot;&quot;&#10;&#10;        // Validaciones Criterios 5-8&#10;        if (name.isEmpty()) {&#10;            binding.tilName.error = &quot;El nombre no puede estar vacío&quot;&#10;        } else if (name.length &gt; 40) {&#10;            binding.tilName.error = &quot;Máximo 40 caracteres&quot;&#10;        } else {&#10;            binding.tilName.error = null&#10;        }&#10;&#10;        if (price.isEmpty()) {&#10;            binding.tilPrice.error = &quot;El precio no puede estar vacío&quot;&#10;        } else if (!price.matches(Regex(&quot;^[0-9]{1,20}$&quot;))) {&#10;            binding.tilPrice.error = &quot;Precio inválido (solo números, hasta 20 dígitos)&quot;&#10;        } else {&#10;            binding.tilPrice.error = null&#10;        }&#10;&#10;        if (quantity.isEmpty()) {&#10;            binding.tilQuantity.error = &quot;La cantidad no puede estar vacía&quot;&#10;        } else if (!quantity.matches(Regex(&quot;^[0-9]{1,4}$&quot;))) {&#10;            binding.tilQuantity.error = &quot;Cantidad inválida (solo números, hasta 4 dígitos)&quot;&#10;        } else {&#10;            binding.tilQuantity.error = null&#10;        }&#10;&#10;        // Usar la función reutilizable para determinar si el formulario es válido&#10;        binding.btnEdit.isEnabled = isFormValid()&#10;    }&#10;&#10;    // Función reusable para evaluar el estado del formulario sin cambiar UI (útil para tests)&#10;    private fun isFormValid(): Boolean {&#10;        val name = binding.etName.text?.toString()?.trim() ?: &quot;&quot;&#10;        val price = binding.etPrice.text?.toString()?.trim() ?: &quot;&quot;&#10;        val quantity = binding.etQuantity.text?.toString()?.trim() ?: &quot;&quot;&#10;&#10;        if (name.isEmpty() || name.length &gt; 40) return false&#10;        if (!price.matches(Regex(&quot;^[0-9]{1,20}$&quot;))) return false&#10;        if (!quantity.matches(Regex(&quot;^[0-9]{1,4}$&quot;))) return false&#10;&#10;        return true&#10;    }&#10;&#10;    private fun observarViewModel() {&#10;        inventoryViewModel.listInventory.observe(viewLifecycleOwner) { lista -&gt;&#10;            currentInventory = lista.find { it.code == productCode }&#10;&#10;            if (currentInventory != null) {&#10;                poblarDatos(currentInventory!!)&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;Producto no encontrado&quot;, Toast.LENGTH_SHORT).show()&#10;                findNavController().navigateUp()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun poblarDatos(producto: Inventory) {&#10;        // Mostrar el código como &quot;Id: &lt;codigo&gt;&quot; directamente para evitar problemas con recursos en tiempo de compilación&#10;        binding.tvCode.text = &quot;Id: ${producto.code}&quot;&#10;        binding.etName.setText(producto.name)&#10;        binding.etPrice.setText(producto.price.toString())&#10;        binding.etQuantity.setText(producto.quantity.toString())&#10;        validarCampos()&#10;    }&#10;&#10;    private fun realizarEdicion() {&#10;        val producto = currentInventory ?: run {&#10;            Toast.makeText(requireContext(), &quot;Error: producto no disponible&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        val nuevoNombre = binding.etName.text.toString().trim()&#10;        val nuevoPrecioStr = binding.etPrice.text.toString().trim()&#10;        val nuevaCantidadStr = binding.etQuantity.text.toString().trim()&#10;&#10;        val nuevoPrecio = nuevoPrecioStr.toIntOrNull()&#10;        val nuevaCantidad = nuevaCantidadStr.toIntOrNull()&#10;&#10;        if (nuevoPrecio == null) {&#10;            Toast.makeText(requireContext(), &quot;Precio inválido&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;        if (nuevaCantidad == null) {&#10;            Toast.makeText(requireContext(), &quot;Cantidad inválida&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        val actualizado = Inventory(&#10;            id = producto.id,&#10;            code = producto.code,&#10;            name = nuevoNombre,&#10;            price = nuevoPrecio,&#10;            quantity = nuevaCantidad&#10;        )&#10;&#10;        inventoryViewModel.updateInventory(actualizado)&#10;        Toast.makeText(requireContext(), &quot;Producto actualizado&quot;, Toast.LENGTH_SHORT).show()&#10;        findNavController().navigate(R.id.action_itemEditFragment_to_homeInventoryFragment)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.miniproyecto1.view.fragment&#10;&#10;import android.os.Bundle&#10;import android.text.Editable&#10;import android.text.InputFilter&#10;import android.text.TextWatcher&#10;import android.text.method.DigitsKeyListener&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.navigation.fragment.findNavController&#10;import com.example.miniproyecto1.R&#10;import com.example.miniproyecto1.databinding.FragmentItemEditBinding&#10;import com.example.miniproyecto1.model.Inventory&#10;import com.example.miniproyecto1.viewmodel.InventoryViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;&#10;@AndroidEntryPoint&#10;class ItemEditFragment : Fragment() {&#10;&#10;    private lateinit var binding: FragmentItemEditBinding&#10;    private val inventoryViewModel: InventoryViewModel by viewModels()&#10;&#10;    private var productCode: Int = -1&#10;    private var currentInventory: Inventory? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        binding = FragmentItemEditBinding.inflate(inflater, container, false)&#10;        binding.lifecycleOwner = viewLifecycleOwner&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        // Recibir código desde el fragment anterior&#10;        productCode = arguments?.getInt(&quot;code&quot;) ?: -1&#10;&#10;        if (productCode == -1) {&#10;            Toast.makeText(requireContext(), &quot;Error: producto no especificado&quot;, Toast.LENGTH_SHORT).show()&#10;            findNavController().navigateUp()&#10;            return&#10;        }&#10;&#10;        configurarToolbar()&#10;        configurarFiltrosYValidacion()&#10;        observarViewModel()&#10;&#10;        // Cargar datos&#10;        inventoryViewModel.getListInventory()&#10;    }&#10;&#10;    private fun configurarToolbar() {&#10;        binding.topAppBar.setNavigationIcon(R.drawable.ic_arrow_back)&#10;        binding.topAppBar.setNavigationOnClickListener {&#10;            // En lugar de crear una nueva instancia de ItemDetailsFragment, simplemente&#10;            // volvemos al fragmento anterior en la pila para evitar ciclos de navegación.&#10;            findNavController().navigateUp()&#10;        }&#10;    }&#10;&#10;    private fun configurarFiltrosYValidacion() {&#10;        // Asegurar que el botón esté deshabilitado hasta que los campos sean válidos (Criterio 5)&#10;        binding.btnEdit.isEnabled = false&#10;&#10;        binding.etName.filters = arrayOf(InputFilter.LengthFilter(40))&#10;        binding.etPrice.filters = arrayOf(InputFilter.LengthFilter(20))&#10;        binding.etQuantity.filters = arrayOf(InputFilter.LengthFilter(4))&#10;&#10;        binding.etPrice.keyListener = DigitsKeyListener.getInstance(&quot;0123456789&quot;)&#10;        binding.etQuantity.keyListener = DigitsKeyListener.getInstance(&quot;0123456789&quot;)&#10;&#10;        val watcher = object : TextWatcher {&#10;            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                validarCampos()&#10;            }&#10;            override fun afterTextChanged(s: Editable?) {}&#10;        }&#10;&#10;        binding.etName.addTextChangedListener(watcher)&#10;        binding.etPrice.addTextChangedListener(watcher)&#10;        binding.etQuantity.addTextChangedListener(watcher)&#10;&#10;        binding.btnEdit.setOnClickListener {&#10;            realizarEdicion()&#10;        }&#10;    }&#10;&#10;    private fun validarCampos() {&#10;        val name = binding.etName.text?.toString()?.trim() ?: &quot;&quot;&#10;        val price = binding.etPrice.text?.toString()?.trim() ?: &quot;&quot;&#10;        val quantity = binding.etQuantity.text?.toString()?.trim() ?: &quot;&quot;&#10;&#10;        // Validaciones Criterios 5-8&#10;        if (name.isEmpty()) {&#10;            binding.tilName.error = &quot;El nombre no puede estar vacío&quot;&#10;        } else if (name.length &gt; 40) {&#10;            binding.tilName.error = &quot;Máximo 40 caracteres&quot;&#10;        } else {&#10;            binding.tilName.error = null&#10;        }&#10;&#10;        if (price.isEmpty()) {&#10;            binding.tilPrice.error = &quot;El precio no puede estar vacío&quot;&#10;        } else if (!price.matches(Regex(&quot;^[0-9]{1,20}$&quot;))) {&#10;            binding.tilPrice.error = &quot;Precio inválido (solo números, hasta 20 dígitos)&quot;&#10;        } else {&#10;            binding.tilPrice.error = null&#10;        }&#10;&#10;        if (quantity.isEmpty()) {&#10;            binding.tilQuantity.error = &quot;La cantidad no puede estar vacía&quot;&#10;        } else if (!quantity.matches(Regex(&quot;^[0-9]{1,4}$&quot;))) {&#10;            binding.tilQuantity.error = &quot;Cantidad inválida (solo números, hasta 4 dígitos)&quot;&#10;        } else {&#10;            binding.tilQuantity.error = null&#10;        }&#10;&#10;        // Usar la función reutilizable para determinar si el formulario es válido&#10;        binding.btnEdit.isEnabled = isFormValid()&#10;    }&#10;&#10;    // Función reusable para evaluar el estado del formulario sin cambiar UI (útil para tests)&#10;    private fun isFormValid(): Boolean {&#10;        val name = binding.etName.text?.toString()?.trim() ?: &quot;&quot;&#10;        val price = binding.etPrice.text?.toString()?.trim() ?: &quot;&quot;&#10;        val quantity = binding.etQuantity.text?.toString()?.trim() ?: &quot;&quot;&#10;&#10;        if (name.isEmpty() || name.length &gt; 40) return false&#10;        if (!price.matches(Regex(&quot;^[0-9]{1,20}$&quot;))) return false&#10;        if (!quantity.matches(Regex(&quot;^[0-9]{1,4}$&quot;))) return false&#10;&#10;        return true&#10;    }&#10;&#10;    private fun observarViewModel() {&#10;        inventoryViewModel.listInventory.observe(viewLifecycleOwner) { lista -&gt;&#10;            currentInventory = lista.find { it.code == productCode }&#10;&#10;            if (currentInventory != null) {&#10;                poblarDatos(currentInventory!!)&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;Producto no encontrado&quot;, Toast.LENGTH_SHORT).show()&#10;                findNavController().navigateUp()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun poblarDatos(producto: Inventory) {&#10;        // Mostrar el código como &quot;Id: &lt;codigo&gt;&quot; directamente para evitar problemas con recursos en tiempo de compilación&#10;        // Usar recurso de string con placeholder para internacionalización (evita advertencias Lint)&#10;        binding.tvCode.text = getString(R.string.label_id, producto.code)&#10;        binding.etName.setText(producto.name)&#10;        binding.etPrice.setText(producto.price.toString())&#10;        binding.etQuantity.setText(producto.quantity.toString())&#10;        validarCampos()&#10;    }&#10;&#10;    private fun realizarEdicion() {&#10;        val producto = currentInventory ?: run {&#10;            Toast.makeText(requireContext(), &quot;Error: producto no disponible&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        val nuevoNombre = binding.etName.text.toString().trim()&#10;        val nuevoPrecioStr = binding.etPrice.text.toString().trim()&#10;        val nuevaCantidadStr = binding.etQuantity.text.toString().trim()&#10;&#10;        val nuevoPrecio = nuevoPrecioStr.toIntOrNull()&#10;        val nuevaCantidad = nuevaCantidadStr.toIntOrNull()&#10;&#10;        if (nuevoPrecio == null) {&#10;            Toast.makeText(requireContext(), &quot;Precio inválido&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;        if (nuevaCantidad == null) {&#10;            Toast.makeText(requireContext(), &quot;Cantidad inválida&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        val actualizado = Inventory(&#10;            id = producto.id,&#10;            code = producto.code,&#10;            name = nuevoNombre,&#10;            price = nuevoPrecio,&#10;            quantity = nuevaCantidad&#10;        )&#10;&#10;        inventoryViewModel.updateInventory(actualizado)&#10;        Toast.makeText(requireContext(), &quot;Producto actualizado&quot;, Toast.LENGTH_SHORT).show()&#10;        findNavController().navigate(R.id.action_itemEditFragment_to_homeInventoryFragment)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>